<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>List of Functions · Zauner</title><meta name="title" content="List of Functions · Zauner"/><meta property="og:title" content="List of Functions · Zauner"/><meta property="twitter:title" content="List of Functions · Zauner"/><meta name="description" content="Documentation for Zauner."/><meta property="og:description" content="Documentation for Zauner."/><meta property="twitter:description" content="Documentation for Zauner."/><meta property="og:url" content="https://github.com/sflammia/Zauner.jl/functions/"/><meta property="twitter:url" content="https://github.com/sflammia/Zauner.jl/functions/"/><link rel="canonical" href="https://github.com/sflammia/Zauner.jl/functions/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Zauner logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Zauner</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Zauner</a></li><li class="is-active"><a class="tocitem" href>List of Functions</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Galois-groups"><span>Galois groups</span></a></li><li><a class="tocitem" href="#Analysis"><span>Analysis</span></a></li><li><a class="tocitem" href="#Binary-Quadratic-Forms"><span>Binary Quadratic Forms</span></a></li><li><a class="tocitem" href="#SL(2,ℤ)"><span>SL(2,ℤ)</span></a></li><li><a class="tocitem" href="#Hirzebruch-Jung-continued-fractions"><span>Hirzebruch-Jung continued fractions</span></a></li><li><a class="tocitem" href="#Ghosts"><span>Ghosts</span></a></li><li><a class="tocitem" href="#Necromancy"><span>Necromancy</span></a></li><li><a class="tocitem" href="#Newton&#39;s-method"><span>Newton&#39;s method</span></a></li><li><a class="tocitem" href="#Validation"><span>Validation</span></a></li><li><a class="tocitem" href="#Real-quadratic-orders"><span>Real quadratic orders</span></a></li><li><a class="tocitem" href="#Property-testing"><span>Property testing</span></a></li><li class="toplevel"><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../tables/">Tables</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>List of Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>List of Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sflammia/Zauner.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/sflammia/Zauner.jl/https://github.com/sflammia/Zauner.jl{commit}/docs/src/functions.md#/docs/src/functions.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p>The following is a list of all exported functions in <code>Zauner</code>.</p><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.AdmissibleTuple-functions" href="#Zauner.AdmissibleTuple-functions"><code>Zauner.AdmissibleTuple</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdmissibleTuple( d::Integer [, Q::QuadBin])
AdmissibleTuple( d::Integer, r::Integer [, Q::QuadBin])
AdmissibleTuple( D::Integer, j::Integer, m::Integer [, Q::QuadBin])

AdmissibleTuple( dQ::Tuple{Integer, QuadBin{ZZRingElem}})
AdmissibleTuple( drQ::Tuple{Integer, Integer, QuadBin{ZZRingElem}})</code></pre><p>Data type for the arithmetic data defining a set of ghost overlaps.</p><p>If only one integer is given, it is interpreted as a dimension and assumed that the rank is <code>r = 1</code>. The syntax that takes three integers <code>(D,j,m)</code> requires that <code>D</code> is a <em>fundamental</em> discriminant for a real quadratic field.</p><p>In all three cases, if the optional argument <code>Q</code> is left unspecified, then it defaults to a principal form given by <code>Q = binary_quadratic_form( 1, 2-n, 1)</code>, where <code>n</code> is the integer <code>(d^2-1)/(r(d-r))</code>, since this has <span>$\mathrm{disc}(Q) = n(n-4)$</span>.</p><p>The final way to specify an input is as a tuple <code>(d,Q)</code> or <code>(d,r,Q)</code>.</p><p>The defined (and precomputed) fields in an <code>AdmissibleTuple</code> are given by:</p><pre><code class="nohighlight hljs">    d ::Integer                     # dimension
    r ::Integer                     # rank
    n ::Integer                     # (d^2-1)/(r*(d-r))
    K ::AbsSimpleNumField           # associated field K = ℚ(√n(n-4))
    D ::Integer                     # fundamental discriminant of K
    f ::Integer                     # conductor, where n*(n-4) = D*f^2
    q ::Integer                     # conductor of Q
    j ::Integer                     # grid vertical position
    m ::Integer                     # grid horozontal position
    a ::AbsSimpleNumFieldElem       # associated field generator √D
    u ::AbsSimpleNumFieldOrderElem  # Zauner unit
    H ::AbsSimpleNumField           # (lazy) ring class field for q*Z(K)
    g ::NumFieldAut                 # (lazy) Galois automorphism in H s.t. g(√D) = -√D
    h ::Integer                     # class number, or degree of H/K
    G ::Vector{Integer}             # orders of class group generators
    c ::Vector{QuadBin}             # basis of generator Q&#39;s for the class group
    Q ::QuadBin                     # binary quadratic form
    L ::Matrix{ZZRingElem}          # S(Q) generator
    k ::Integer                     # L^k = I mod d
    A ::Matrix{ZZRingElem}          # S_d(Q) generator
    x ::BigFloat                    # positive root of Q
    R ::BigFloat                    # log of u</code></pre><p>The fields marked &#39;(lazy)&#39;, namely &#39;H&#39; and &#39;g&#39;, are not initialized at first since their computation is substantially more expensive than the other fields. Once they have been computed their values are memoized and do not have to be recomputed.</p><p>From the way that <code>H</code> is computed currently, <code>K</code> is not recognized as a subfield. This could lead to some non-intuitive results. For example, the quadratic generator <code>a</code> is an element of <code>K</code>, but <em>not</em> a recognized element of <code>H</code>. If an explicit embedding is needed, it can be obtained using <code>is_subfield(K,H)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; AdmissibleTuple(5)
AdmissibleTuple( d = 5, K = ℚ(√12), q = 1, Q = ⟨1,-4,1⟩, h = 1 )</code></pre><pre><code class="language-julia-repl hljs">julia&gt; AdmissibleTuple(11,3)
AdmissibleTuple( d = 11, r = 3, K = ℚ(√5), q = 1, Q = ⟨1,-3,1⟩, h = 1 )</code></pre><pre><code class="language-julia-repl hljs">julia&gt; AdmissibleTuple(5,1,1)
AdmissibleTuple( d = 4, K = ℚ(√5), q = 1, Q = ⟨1,-3,1⟩, h = 1 )</code></pre><pre><code class="language-julia-repl hljs">julia&gt; AdmissibleTuple(11,binary_quadratic_form(3,-12,4))
AdmissibleTuple( d = 11, K = ℚ(√24), q = 2, Q = ⟨3,-12,4⟩, h = 2 )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/utils.jl#L68-L138">source</a></section></article><h2 id="Galois-groups"><a class="docs-heading-anchor" href="#Galois-groups">Galois groups</a><a id="Galois-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Galois-groups" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.centralizer_elements-functions" href="#Zauner.centralizer_elements-functions"><code>Zauner.centralizer_elements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">centralizer_elements(F::AdmissibleTuple)</code></pre><p>Compute the elements of <span>$\mathrm{GL}(2,\mathbb{Z}/d&#39;)$</span> that are in the centralizer of the stability group for <code>F</code>.</p><p><strong>Examples</strong></p><p>The centralizer for <span>$d=5$</span> has 24 elements.</p><pre><code class="language-julia-repl hljs">julia&gt; F = AdmissibleTuple(5);

julia&gt; cent = centralizer_elements(F);

julia&gt; length(cent)
24</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/galois.jl#L85-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.galois_elements-functions" href="#Zauner.galois_elements-functions"><code>Zauner.galois_elements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">galois_elements(F::AdmissibleTuple)
galois_elements(d::Integer, gens::Vector{Matrix{ZZRingElem}}, ords::Vector{Integer})</code></pre><p>Compute one element from each coset of <span>$\mathcal{M}/\mathcal{S}$</span> where <span>$\mathcal{M}$</span> is a maximal abelian subgroup of <span>$\mathrm{GL}(2,\mathbb{Z}/d&#39;)$</span> and <span>$\mathcal{S}$</span> is the stabilizer of <code>F</code>. The second form takes the dimension <code>d</code> and the generators and orders of generators for the galois group, as is computed by <code>galois_normal_form</code>. The output is an array of <code>Matrix{ZZRingElem}</code> elements whose size is the the same as <code>ords</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/galois.jl#L269-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.galois_group_structure-functions" href="#Zauner.galois_group_structure-functions"><code>Zauner.galois_group_structure</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">galois_group_structure(F::AdmissibleTuple)</code></pre><p>Compute the canonical form (decomposition into cyclic groups) for the Galois group using the Smith normal form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/galois.jl#L306-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.galois_normal_form-functions" href="#Zauner.galois_normal_form-functions"><code>Zauner.galois_normal_form</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">galois_normal_form(F::AdmissibleTuple)</code></pre><p>Compute the normal form of the group <span>$\mathcal{M}/\mathcal{S}$</span> where <span>$\mathcal{M}$</span> is a maximal abelian subgroup of <span>$\mathrm{GL}(2,\mathbb{Z}/d&#39;)$</span> and <span>$\mathcal{S}$</span> is the stabilizer of <code>F</code>. This is group is (conjecturally) isomorphic to the Galois group. The output is a tuple <code>(g,n)</code> where <code>g</code> is a vector of generator matrices and <code>n</code> is a vector of the orders of those matrices in <span>$\mathcal{M}/\mathcal{S}$</span>. This corresponds to the canonical decomposition <span>$\mathbb{Z}/n_1 ⊕ \mathbb{Z}/n_2 ⊕ ... ⊕ \mathbb{Z}/n_k$</span> where the <span>$n_j$</span> are each prime powers. The factors are canonical up to permutation (though the generators are not).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; F = AdmissibleTuple( 7, QuadBin(2,-4,1))
AdmissibleTuple( d = 7, K = ℚ(√8), q = 1, Q = ⟨2,-4,1⟩, h = 1 )

julia&gt; g, n = galois_normal_form(F)
(Matrix{ZZRingElem}[[6 0; 0 6], [2 0; 0 2]], [2, 3])

julia&gt; F = AdmissibleTuple(9)
AdmissibleTuple( d = 9, K = ℚ(√60), q = 1, Q = ⟨1,-8,1⟩, h = 2 )

julia&gt; g, n = galois_normal_form(F)
(Matrix{ZZRingElem}[[8 5; 4 3], [8 0; 0 8], [7 0; 0 7]], [3, 2, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/galois.jl#L164-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.galois_orbit-functions" href="#Zauner.galois_orbit-functions"><code>Zauner.galois_orbit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">galois_orbit(F::AdmissibleTuple)
galois_orbit(F::AdmissibleTuple, T::Matrix{ZZRingElem}, n::Integer)</code></pre><p>Compute a maximal Galois orbit. Output is a vector of <code>Vector{Integer}</code> elements lying on a maximal orbit for the tuple <code>F</code>. The second form computes the Galois orbit with the centralizer subgroup generated by <code>T</code> of order <code>n</code> removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/galois.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.galois_order_orbit-functions" href="#Zauner.galois_order_orbit-functions"><code>Zauner.galois_order_orbit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">galois_order_orbit(F::AdmissibleTuple)</code></pre><p>Compute the orders of the elements of the Galois group and a maximal orbit, output as a tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/galois.jl#L290-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.stabilizer_elements-functions" href="#Zauner.stabilizer_elements-functions"><code>Zauner.stabilizer_elements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stabilizer_elements(F::AdmissibleTuple)</code></pre><p>Compute the elements of <span>$\mathrm{GL}(2,\mathbb{Z}/d&#39;)$</span> that are in the complete stabilizer for <code>F</code>, including the extra antiunitary symmetry (if present). The elements are ordered so that the identity element is first.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; F = AdmissibleTuple(7)
AdmissibleTuple( d = 7, K = ℚ(√8), q = 2, Q = ⟨1,-6,1⟩, h = 1 )

julia&gt; stabilizer_elements(F)
3-element Vector{Matrix{ZZRingElem}}:
 [1 0; 0 1]
 [6 6; 1 0]
 [0 1; 6 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/galois.jl#L125-L143">source</a></section></article><h2 id="Analysis"><a class="docs-heading-anchor" href="#Analysis">Analysis</a><a id="Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.double_sine-functions" href="#Zauner.double_sine-functions"><code>Zauner.double_sine</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">double_sine(x,ω1,ω2 [; points=21])</code></pre><p>The double sine function, defined in terms of the double gamma function following Shintani&#39;s convention:</p><p class="math-container">\[S_2(x,\boldsymbol{\omega}) = \frac{\Gamma_2(x,\boldsymbol{\omega})}{\Gamma_2(\omega_1+\omega_2-x,\boldsymbol{\omega})}\]</p><p>This is currently implemented for real values only.</p><p>When <span>$0 &lt; x &lt; ω_1 + ω_2$</span>, <span>$\log S_2$</span> has the integral representation</p><p class="math-container">\[    \log S_2(x,\boldsymbol{ω}) = \frac12 \int_0^\infty \left(\frac{\sinh\bigl((ω_1 + ω_2 - 2x)t\bigr)}{\sinh(ω_1 t)\sinh(ω_2 t)} - \frac{ω_1 + ω_2 - 2 x}{ω_1 ω_2 t}\right) \frac{\mathrm{d}t}{t}\]</p><p>Evaluation proceeds via numerical integration using adaptive Gauss quadrature using the optional keyword argument <code>points</code> set to 21 by default.</p><p>If <span>$x$</span> is outside this fundamental domain, then the following period shift formulas can be applied until the integral formula can be applied. We have</p><p class="math-container">\[    S_2(x,\boldsymbol{ω}) = S_2(x + ω_1,\boldsymbol{ω}) / \bigl(2 \sin(\pi x / ω_2) \bigr)\]</p><p>and similarly with <span>$ω_1$</span> and <span>$ω_2$</span> exchanged. Note that <span>$S_2(x,\boldsymbol{ω})$</span> is symmetric with respect to <span>$ω_1, ω_2$</span>. In our implementation, we recursively shift by <span>$ω_2$</span> until the fundamental domain is reached.</p><p><em>Note</em>: Many authors, including Koyama &amp; Kurokawa, Kurokawa &amp; Koyama, and Tangedal, use a convention which replaces <span>$S_2$</span> by <span>$1/S_2$</span> relative to our convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/double_sine.jl#L4-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.e-functions" href="#Zauner.e-functions"><code>Zauner.e</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">e(z)</code></pre><p>Normalized exponential function, <span>$e(z) = \exp(2 \pi i z)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/analytic.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.q_pochhammer-functions" href="#Zauner.q_pochhammer-functions"><code>Zauner.q_pochhammer</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">q_pochhammer(a, q, n)</code></pre><p>Finite q-Pochhammer symbol, <span>$\prod_{k=0}^{n-1} \bigl(1-a q^k\bigr)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/analytic.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.q_pochhammer_exp-functions" href="#Zauner.q_pochhammer_exp-functions"><code>Zauner.q_pochhammer_exp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">q_pochhammer_exp(z, τ, n)</code></pre><p>Finite exponential-variant q-Pochhammer symbol, extended to include <span>$n &lt; 0$</span>. Defined as</p><p class="math-container">\[\varpi_n(z,\tau) =
\begin{cases}
        \prod_{j=0}^{n-1}\bigl(1-\mathrm{e}^{2 \pi i (z+j \tau)}\bigr)
        \qquad &amp; n&gt;0
        \\
        1 \qquad &amp; n=0
        \\
        \prod_{j=n}^{-1}\bigl(1-\mathrm{e}^{2 \pi i (z+j \tau)}\bigr)^{-1}
        \qquad &amp; n&lt;0
\end{cases}\,.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/analytic.jl#L20-L37">source</a></section></article><h2 id="Binary-Quadratic-Forms"><a class="docs-heading-anchor" href="#Binary-Quadratic-Forms">Binary Quadratic Forms</a><a id="Binary-Quadratic-Forms-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-Quadratic-Forms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.qmat-functions" href="#Zauner.qmat-functions"><code>Zauner.qmat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qmat(Q::QuadBin)</code></pre><p>The matrix of a quadratic form <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/quadform.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.quadbinid-functions" href="#Zauner.quadbinid-functions"><code>Zauner.quadbinid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quadbinid(D)</code></pre><p>The principal reduced form with discriminant D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/quadform.jl#L24-L28">source</a></section></article><h2 id="SL(2,ℤ)"><a class="docs-heading-anchor" href="#SL(2,ℤ)">SL(2,ℤ)</a><a id="SL(2,ℤ)-1"></a><a class="docs-heading-anchor-permalink" href="#SL(2,ℤ)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.is_sl2z-functions" href="#Zauner.is_sl2z-functions"><code>Zauner.is_sl2z</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_sl2z(M)</code></pre><p>Returns <code>true</code> if the matrix <code>M</code> is a 2x2 integer matrix with determinant 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/sl2z.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.psl2word-functions" href="#Zauner.psl2word-functions"><code>Zauner.psl2word</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">psl2word(v::Vector)
psl2word(A::Matrix)</code></pre><p>Return the product <span>$T^{v_1} S T^{v_2} S...S T^{v_n}$</span> where <span>$S$</span> and <span>$T$</span> are the standard generators of <span>$\mathrm{SL}(2,\mathbb{Z})$</span>.</p><p>Decompose a matrix <code>A</code> in <span>$\mathrm{SL}(2,\mathbb{Z})$</span> into a product of <span>$S$</span> and <span>$T$</span> generators, modulo <span>$-I$</span>. Reduction is done using rounding up with ceiling (Hirzebruch-Jung or negative regular continued fraction reduction) and returning a product strictly in terms of <span>$S$</span> and <span>$T$</span> except for the first or final element, which might be negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/sl2z.jl#L56-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.rademacher-functions" href="#Zauner.rademacher-functions"><code>Zauner.rademacher</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rademacher(M)</code></pre><p>Rademacher invariant of the <span>$\mathrm{SL}(2,\mathbb{Z})$</span> matrix <code>M</code>. Reference: Hans Rademacher Zur Theorie der Dedekindschen Summen Mathematische Zeitschriften vol 63, pp. 445–463 (1955).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/sl2z.jl#L36-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.sl2zorder-functions" href="#Zauner.sl2zorder-functions"><code>Zauner.sl2zorder</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sl2zorder(L, d)</code></pre><p>Find the order of <span>$L \bmod d$</span> where <span>$L$</span> is in <span>$\mathrm{SL}(2,\mathbb{Z})$</span>. Brute force algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/sl2z.jl#L17-L22">source</a></section></article><h2 id="Hirzebruch-Jung-continued-fractions"><a class="docs-heading-anchor" href="#Hirzebruch-Jung-continued-fractions">Hirzebruch-Jung continued fractions</a><a id="Hirzebruch-Jung-continued-fractions-1"></a><a class="docs-heading-anchor-permalink" href="#Hirzebruch-Jung-continued-fractions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.minimal_hj_stabilizer-functions" href="#Zauner.minimal_hj_stabilizer-functions"><code>Zauner.minimal_hj_stabilizer</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimal_hj_stabilizer(V::Vector{QuadBin{ZZRingElem}},d)</code></pre><p>Returns a minimal form <code>Q</code> among those in <code>V</code>. Specifically, if <code>V</code> is a reduced HJ orbit then the output <code>Q</code> minimizes the length of the HJ expansion of the stabilizer of <code>Q</code> modulo <code>d</code>. To break ties on length, the algorithm further chooses a minimal form by minimizing according first to the sum of the absolute coefficients, then by the maximum absolute coefficient. See the internal function <code>_quadcompare_sum_then_max</code> for details of the comparison function used for sorting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/hj.jl#L41-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.reduced_hj_orbit-functions" href="#Zauner.reduced_hj_orbit-functions"><code>Zauner.reduced_hj_orbit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reduced_hj_orbit(q::QuadBin{ZZRingElem})</code></pre><p>Returns the reduced orbit under HJ reduction.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reduced_hj_orbit(binary_quadratic_form(1,-4,1))
3-element Vector{QuadBin{ZZRingElem}}:
 Binary quadratic form over ZZ: x^2 - 4*x*y + y^2
 Binary quadratic form over ZZ: 3*x^2 - 6*x*y + 2*y^2
 Binary quadratic form over ZZ: 2*x^2 - 6*x*y + 3*y^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/hj.jl#L12-L26">source</a></section></article><h2 id="Ghosts"><a class="docs-heading-anchor" href="#Ghosts">Ghosts</a><a id="Ghosts-1"></a><a class="docs-heading-anchor-permalink" href="#Ghosts" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.ghost-functions" href="#Zauner.ghost-functions"><code>Zauner.ghost</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ghost(F:AdmissibleTuple)</code></pre><p>Compute a ghost as a d × d matrix from the admissible tuple <code>F</code>.</p><p>Only rank-1 ghosts are supported at this time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/analytic.jl#L53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.ghostbasis-functions" href="#Zauner.ghostbasis-functions"><code>Zauner.ghostbasis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ghostbasis(d)</code></pre><p>Compute a generating set (under Gauss composition) for the allowed quadratic forms in dimension d.</p><p>This returns a dictionary where each key is a divisor <code>f</code> of the conductor of <code>D = (d+1)*(d-3)</code> and each value is the tuple <code>(c,Q)</code> where <code>c[k]</code> is the order of <code>Q[k]</code> under Gauss composition.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ghostbasis(15)
Dict{ZZRingElem, Tuple{Vector{ZZRingElem}, Vector{QuadBin}}} with 3 entries:
  4 =&gt; ([2], [Binary quadratic form over ZZ: 3*x^2 + 12*x*y - 4*y^2])
  2 =&gt; ([1], [Binary quadratic form over ZZ: x^2 + 6*x*y - 3*y^2])
  1 =&gt; ([1], [Binary quadratic form over ZZ: x^2 + 2*x*y - 2*y^2])</code></pre><p>In this example, <code>Q = QuadBin(3,12,-4)</code> has order 2, so we have <code>Q^2 == QuadBin(1,12,-12)</code> since this is the principal form with the same discriminant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/algebraic.jl#L322-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.ghostclassfield-functions" href="#Zauner.ghostclassfield-functions"><code>Zauner.ghostclassfield</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ghostclassfield( K::AbsSimpleNumField, q)
ghostclassfield( F::AdmissibleTuple)</code></pre><p>Compute the ring class field for the order q*ℤ(K) where ℤ(K) is the maximal order in K. The output is an LLL-reduced <code>AbsSimpleNumField</code>, and so is an absolute field rather than a relative extension.</p><p>Given an <code>AdmissibleTuple</code> <code>F</code> it initializes the field <code>F.H</code> to be this ring class field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/algebraic.jl#L172-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.ghostelements-functions" href="#Zauner.ghostelements-functions"><code>Zauner.ghostelements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ghostelements(d)</code></pre><p>Compute a representative quadratic form for each ghost class in dimension <code>d</code>. There are a total of <code>numsics(d)</code> such forms. These forms are merely Euclidean reduced, not Hirzebruch-Jung reduced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/algebraic.jl#L366-L372">source</a></section></article><h2 id="Necromancy"><a class="docs-heading-anchor" href="#Necromancy">Necromancy</a><a id="Necromancy-1"></a><a class="docs-heading-anchor-permalink" href="#Necromancy" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.guess_int_null_vec-functions" href="#Zauner.guess_int_null_vec-functions"><code>Zauner.guess_int_null_vec</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">guess_int_null_vec( x::Vector{BigFloat})</code></pre><p>Use LLL to find an integer relation among the elements of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; guess_int_null_vec(BigFloat.([1; sin(big(pi)/8)^2; sin(big(pi)/4)]))
3-element Vector{BigInt}:
 -1
  2
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/integer_relations.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.matrix_completion-functions" href="#Zauner.matrix_completion-functions"><code>Zauner.matrix_completion</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matrix_completion( nu::AbstractArray, F::AdmissibleTuple
[; verbose::Bool = false, shift::Integer = 0, test::Bool = false,
max_iters = 1e5, eps_abs = 1e-7, eps_infeas = 1e-7, eps_rel = 1e-7])</code></pre><p>Given the SIC phase overlaps <code>nu</code> on a maximal galois orbit, compute the associated SIC fiducial vector <code>ψ</code>. If the input does not correspond to a valid SIC with admissible data <code>F</code>, then the output is unpredictable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/matrix_completion.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.necromancy-functions" href="#Zauner.necromancy-functions"><code>Zauner.necromancy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">necromancy( F::AdmissibleTuple [; max_prec = 2^20, verbose = false])</code></pre><p>Compute a numerical approximations to a SIC associated to the <code>AdmissibleTuple</code> <code>F</code>. The maximum number of bits used in integer relation finding is set to <code>max_prec</code> (default of 1 Mb) and <code>verbose</code> can be toggled <code>true</code> or <code>false</code>.</p><p><strong>Examples</strong></p><p>Check that the principal SIC in <span>$d=7$</span> satisfies the equiangularity conditions.</p><pre><code class="nohighlight hljs">julia&gt; d = 7; F = AdmissibleTuple(d)
AdmissibleTuple( d = 7, K = ℚ(√8), q = 2, Q = ⟨1,-6,1⟩, h = 1 )

julia&gt; ψ = necromancy(F);

julia&gt; all([ abs2(ψ&#39;wh(p,ψ)) for p=1:d^2-1] .≈ 1/(d+1))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/invariants.jl#L56-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.pow_to_elem_sym_poly-functions" href="#Zauner.pow_to_elem_sym_poly-functions"><code>Zauner.pow_to_elem_sym_poly</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pow_to_elem_sym_poly( p::AbstractVector)</code></pre><p>Convert a vector of power sums to elementary symmetric polynomials. Assumes that that <code>p[k]</code> is the power sum of degree <code>k</code>. No check is done to ensure that the input is a valid collection of power sums, it simply applies the relevant recursion relation. Output <code>e</code> is indexed so that <code>e[1] == 1</code> is the zeroth elementary symmetric polynomial and <code>length(e) == length(p)+1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/precision_bump.jl#L245-L252">source</a></section></article><h2 id="Newton&#39;s-method"><a class="docs-heading-anchor" href="#Newton&#39;s-method">Newton&#39;s method</a><a id="Newton&#39;s-method-1"></a><a class="docs-heading-anchor-permalink" href="#Newton&#39;s-method" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.precision_bump-functions" href="#Zauner.precision_bump-functions"><code>Zauner.precision_bump</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">precision_bump(ψ::Vector{Complex{BigFloat}}, prec::Integer [; base::Integer = 10, verbose::Bool = true])
precision_bump(ψ::Vector{Complex{BigFloat}}, f::Function, prec::Integer [; base::Integer = 10, verbose::Bool = true])</code></pre><p>Attempt to use Newton&#39;s method to improve the precision of <code>ψ</code> to at least <code>prec</code> digits in base <code>base</code>. In the second version, the function <code>f</code> is used for root finding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/precision_bump.jl#L160-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.precision_bump!-functions" href="#Zauner.precision_bump!-functions"><code>Zauner.precision_bump!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">precision_bump!(z::Vector{BigFloat}, prec::Integer [; base::Integer = 10, verbose::Bool = true])
precision_bump!(z::Vector{BigFloat}, f::Function, prec::Integer [; base::Integer = 10, verbose::Bool = true])</code></pre><p>Attempt to use Newton&#39;s method to improve the precision of <code>z</code> to at least <code>prec</code> digits in base <code>base</code>, where <code>z</code> is the real projective representation of <code>ψ</code>. In the second version, the function <code>f</code> is used for root finding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/precision_bump.jl#L175-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.re_im_proj-functions" href="#Zauner.re_im_proj-functions"><code>Zauner.re_im_proj</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">re_im_proj(ψ::Vector{Complex{BigFloat}})
re_im_proj(z::Vector{BigFloat})</code></pre><p>Stack the real and imaginary parts of the vector <code>ψ</code> and normalize so that the first coordinate, assumed nonzero, is normalized to 1 and then dropped.</p><p>If called with type <code>Vector{BigFloat}</code> then it does the inverse transformation, taking an even-length real vector to a complex one with unit first coordinate.</p><p><strong>Examples</strong></p><p>A simple example:</p><pre><code class="language-julia hljs">v = Complex{BigFloat}.([ 1; im; -1; -im])
re_im_proj(v)

# output

6-element Vector{BigFloat}:
  0.0
 -1.0
  0.0
  1.0
  0.0
 -1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/precision_bump.jl#L3-L29">source</a></section></article><h2 id="Validation"><a class="docs-heading-anchor" href="#Validation">Validation</a><a id="Validation-1"></a><a class="docs-heading-anchor-permalink" href="#Validation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.ghost_frame_test-functions" href="#Zauner.ghost_frame_test-functions"><code>Zauner.ghost_frame_test</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ghost_frame_test(ψ::AbstractVector)</code></pre><p>Return the maximum absolute deviation of the pointwise frame conditions. This is the ghost analog of eq. 8 of arXiv:0707.2071.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/validation.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.ghost_overlap_test-functions" href="#Zauner.ghost_overlap_test-functions"><code>Zauner.ghost_overlap_test</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ghost_overlap_test(ψ::AbstractVector)</code></pre><p>Check the ghost overlap conditions. If all ghost overlaps are approximately real, it returns</p><p class="math-container">\[\max_{\boldsymbol{p} \not=\boldsymbol{0}} \bigl|\nu_{\boldsymbol{p}} \nu_{-\boldsymbol{p}} - \tfrac{1}{d+1}\bigr|\,.\]</p><p>If they aren&#39;t approximately real it throws an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/validation.jl#L23-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.sic_frame_test-functions" href="#Zauner.sic_frame_test-functions"><code>Zauner.sic_frame_test</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sic_frame_test(ψ::AbstractVector)</code></pre><p>Return the absolute deviation of the pointwise conditions on the frame potential from eq. 8 of arXiv:0707.2071. Let <span>$T(k,l) = \sum_j \psi_{j}\psi_{j+k}^* \psi_{j+l}^* \psi_{j+k+l}$</span>, and recall that <span>$\psi$</span> is a SIC if and only if <span>$T(k,l) - \frac{\delta_{k,0}+\delta_{l,0}}{d+1} = 0$</span>. The function returns the maximum absolute deviation from these conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/validation.jl#L48-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.sic_overlap_test-functions" href="#Zauner.sic_overlap_test-functions"><code>Zauner.sic_overlap_test</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sic_overlap_test(ψ::AbstractVector)</code></pre><p>Check the SIC equiangularity conditions by returning</p><p class="math-container">\[\max_{\boldsymbol{p} \not=\boldsymbol{0}} \bigl|\nu_{\boldsymbol{p}} \nu_{-\boldsymbol{p}} - \tfrac{1}{d+1}\bigr|\,,\]</p><p>where <span>$\nu_{\boldsymbol{p}} = \langle\psi|D_{\boldsymbol{p}}|\psi\rangle$</span> are the SIC overlaps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/validation.jl#L3-L11">source</a></section></article><h2 id="Real-quadratic-orders"><a class="docs-heading-anchor" href="#Real-quadratic-orders">Real quadratic orders</a><a id="Real-quadratic-orders-1"></a><a class="docs-heading-anchor-permalink" href="#Real-quadratic-orders" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.class_group_structure-functions" href="#Zauner.class_group_structure-functions"><code>Zauner.class_group_structure</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">class_group_structure(D)</code></pre><p>Returns class group structure for the quadratic order with disciminant <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/algebraic.jl#L254-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.coredisc-functions" href="#Zauner.coredisc-functions"><code>Zauner.coredisc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coredisc(D)
coredisc(Q::QuadBin)</code></pre><p>Outputs a tuple <code>(Δ,f)</code> of the fundamental discriminant <code>Δ</code> and conductor <code>f</code> of <code>D</code>, or of a binary quadratic form with discriminant <code>D</code>.</p><p><strong>Examples</strong></p><p>Here are two examples with fundamental discriminant 5 and conductor 3.</p><pre><code class="language-julia-repl hljs">julia&gt; coredisc(45) # 45 = 3^2 * 5
(5, 3)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; coredisc( binary_quadratic_form(1,-7,1) ) # -4*det( [1 -7//2; -7//2 1]) == 3^2 * 5
(5, 3)</code></pre><p>See also <code>conductor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/algebraic.jl#L53-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.pell-functions" href="#Zauner.pell-functions"><code>Zauner.pell</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pell(D)
pell(Q::QuadBin)
pell(Zω::AbsSimpleNumFieldOrder)</code></pre><p>Finds the least unit &gt; 1 having norm 1 for the discriminant <code>D</code>, for the binary quadratic form with discriminant <code>D</code>, or the quadratic order ℤ(ω) where <span>$ω = \frac{1}{2}\bigl( (D \mod 4) +  \sqrt{D}\bigr)$</span>.</p><p><strong>Example</strong></p><p>The fundamental unit for <span>$ℚ(\sqrt{5})$</span> is <span>$(\sqrt{5}+1)/2$</span>, but this has norm -1, so we return the square of this.</p><pre><code class="language-julia-repl hljs">julia&gt; pell(5)
1//2*sqrt(5) + 3//2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/algebraic.jl#L88-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.pellreg-functions" href="#Zauner.pellreg-functions"><code>Zauner.pellreg</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pellreg(D)
pellreg(Q::QuadBin)
pellreg(Zω::AbsSimpleNumFieldOrder)</code></pre><p>Finds the least unit &gt; 1 having norm 1 for the discriminant <code>D</code>, for the binary quadratic form with discriminant <code>D</code>, or the quadratic order ℤ(ω) where <span>$ω = \frac{1}{2}\bigl( (D \mod 4) +  \sqrt{D}\bigr)$</span>. The output is a tuple with the unit and a <code>BigFloat</code> of the log of that unit (which is just the regulator of ℤ(ω), or twice that if the fundamental unit has norm -1).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>A limitation of the current implementation is that the regulator is only correct to about 128 bits, even though it returns a number to the current precision of <code>BigFloat</code>.</p></div></div><p>See also <code>pell</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/algebraic.jl#L131-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.quadclassunit-functions" href="#Zauner.quadclassunit-functions"><code>Zauner.quadclassunit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quadclassunit(D)</code></pre><p>Returns class group and unit group data for the quadratic order with disciminant <code>D</code>. Let <span>$\omega = \bigl(\Delta\bmod 4 + \sqrt{\Delta}\bigr)/2$</span>, so that a <span>$\mathbb{Z}$</span>-basis is <span>$\mathbb{Z}+\omega\mathbb{Z}$</span>. Then the output is a tuple <code>(h,c,b,u)</code>, where</p><ul><li><code>h</code> is the class number,</li><li><code>c</code> is an integer vector for the cycle stucture of the class group, <span>$\mathbb{Z}/{n_1} + \ldots + \mathbb{Z}/{n_r}$</span>.</li><li><code>b</code> is a vector of binary quadratic forms that generate the corresponding factor in the class group,</li><li><code>u</code> is the totally positive fundamental unit with norm 1, written as <code>[x,y]</code> in the above basis.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/algebraic.jl#L212-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.signswitch-functions" href="#Zauner.signswitch-functions"><code>Zauner.signswitch</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">signswitch( H::AbsSimpleNumField, D::Integer)
signswitch( F::AdmissibleTuple)</code></pre><p>If <code>H</code> is the (absolute) ring class field for a ghost with fundamental discriminant <code>D</code> with some conductor, then this finds a sign-switching Galois automorphism <code>g</code> on <code>H</code>, that is <span>$g\bigl(\sqrt{D}\bigr) = -\sqrt{D}$</span>.</p><p>If <code>F</code> is an <code>AdmissibleTuple</code> then is initializes the field <code>F.g</code>. This requires that the field <code>F.H</code> has already been initialized with <code>ghostclassfield</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/algebraic.jl#L190-L198">source</a></section></article><h2 id="Property-testing"><a class="docs-heading-anchor" href="#Property-testing">Property testing</a><a id="Property-testing-1"></a><a class="docs-heading-anchor-permalink" href="#Property-testing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.has_fa_symmetry-functions" href="#Zauner.has_fa_symmetry-functions"><code>Zauner.has_fa_symmetry</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_fa_symmetry(F::AdmissibleTuple)</code></pre><p>Test for <span>$F_a$</span> symmetry as opposed to Zauner (<span>$F_z$</span>) symmetry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/utils.jl#L395-L399">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.is_admissible-functions" href="#Zauner.is_admissible-functions"><code>Zauner.is_admissible</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_admissible( d::Integer [, Q::QuadBin])
is_admissible( d::Integer, r::Integer [, Q::QuadBin])
is_admissible( D::Integer, j::Integer, m::Integer [, Q::QuadBin])</code></pre><p>Test whether the arguments form an admissible tuple.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_admissible(5,1)
true

julia&gt; is_admissible(5,2)
false

julia&gt; is_admissible(5,1,1)
true

julia&gt; is_admissible(5,2,1,binary_quadratic_form(1,-7,1))
true

julia&gt; is_admissible(11,1,binary_quadratic_form(3,-12,4))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/utils.jl#L247-L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.is_antiunitary-functions" href="#Zauner.is_antiunitary-functions"><code>Zauner.is_antiunitary</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_antiunitary(F::AdmissibleTuple)</code></pre><p>Test if the tuple <code>F</code> has antiunitary symmetry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/utils.jl#L327-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.is_antiunitary_with_generator-functions" href="#Zauner.is_antiunitary_with_generator-functions"><code>Zauner.is_antiunitary_with_generator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_antiunitary_with_generator(F::AdmissibleTuple)</code></pre><p>Test if the tuple <code>F</code> has antiunitary symmetry and return a tuple: if the first output is <code>true</code>, the second element of the tuple is a symmetry generator, and if <code>false</code>, the second output is the zero matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/utils.jl#L358-L362">source</a></section></article><h1 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.dq-functions" href="#Zauner.dq-functions"><code>Zauner.dq</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dq(k)</code></pre><p>Precomputed values of admissible tuples <code>(d,Q)</code> with <code>d ≤ 256</code>, comprising the first 3292 such inequivalent tuples when ordered by dimension. The forms <code>Q</code> have been chosen (non-uniquely) to minimize the period of the Hirzebruch-Jung continued fraction expansion of their positive root.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dq(1)
(4, Binary quadratic form over ZZ: x^2 - 3*x*y + y^2)</code></pre><p>It can also be called with collections to access multiple tuples.</p><pre><code class="language-julia-repl hljs">julia&gt; dq(20:23)
4-element Vector{Tuple{Int64, QuadBin{ZZRingElem}}}:
 (15, Binary quadratic form over ZZ: x^2 - 4*x*y + y^2)
 (15, Binary quadratic form over ZZ: 4*x^2 - 8*x*y + y^2)
 (15, Binary quadratic form over ZZ: x^2 - 14*x*y + y^2)
 (15, Binary quadratic form over ZZ: 11*x^2 - 18*x*y + 3*y^2)</code></pre><p>The associated <code>AdmissibleTuple</code> can be obtained directly.</p><pre><code class="language-julia-repl hljs">julia&gt; AdmissibleTuple(dq(2))
AdmissibleTuple( d = 5, K = ℚ(√12), q = 1, Q = ⟨1,-4,1⟩, h = 1 )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/dQ.jl#L3297-L3323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.numsics-functions" href="#Zauner.numsics-functions"><code>Zauner.numsics</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">numsics(d)</code></pre><p>Number of WH 1-SICs in dimension d, modulo EC orbits.</p><p><strong>Example</strong></p><p>Here are the number of inequivalent 1-SICs for dimensions 4-15:</p><pre><code class="language-julia-repl hljs">julia&gt; foreach(d -&gt; println( (d, numsics(d)) ), 4:15)
(4, 1)
(5, 1)
(6, 1)
(7, 2)
(8, 2)
(9, 2)
(10, 1)
(11, 3)
(12, 2)
(13, 2)
(14, 2)
(15, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/algebraic.jl#L274-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.radix-functions" href="#Zauner.radix-functions"><code>Zauner.radix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">radix(n,r)</code></pre><p>The <code>length(r)</code> least significant digits of the integer <code>n</code> in mixed radix <code>r = [r1; r2; ...; rk]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; radix(5,[2; 2; 2; 2; 2])
5-element Vector{Int64}:
 0
 0
 1
 0
 1

julia&gt; radix(86400,[7; 24; 60; 60])
4-element Vector{Int64}:
 1
 0
 0
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/utils.jl#L9-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Zauner.wh-functions" href="#Zauner.wh-functions"><code>Zauner.wh</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">wh( p::Vector{&lt;:Integer}, d::Integer [, T::Type = BigFloat])
wh( m::Integer, n::Integer, d::Integer [, T::Type = BigFloat])

wh( p::Vector{&lt;:Integer}, v::Vector)
wh( m::Integer, n::Integer, v::Vector)
wh( n::Integer, v::Vector)</code></pre><p>Weyl-Heisenberg displacement operators. We have <code>wh(p,q,d) == wh([p,q],d)</code> acts on the standard basis as <span>$|k\rangle \to v_d^{p q} ω_d^{q}|k+p\rangle$</span>, where arithmetic inside the ket is modulo <span>$d$</span> and where <span>$ω_d = v_d^2$</span> and <span>$v_d = -\mathrm{e}^{i π/d}$</span>. These forms explicitly construct the matrix that acts this way where <code>0</code> is the first element of the basis.</p><p>The forms <code>wh(p,v)</code> or <code>wh(m,n,v)</code> give the action onto the vector <code>v</code> without explicitly forming the matrix. This is much faster when working with high dimensions or high precision. The form <code>wh(n,v)</code> with <code>d = length(v)</code> simply converts the integer <code>n</code> into the base-<code>d</code> expansion <span>$n = n_1 d + n_0$</span> and calls <code>wh([n1,n0],v)</code>. Tuples can also be used in place of vectors in these function calls.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; wh(2,3,4)
4×4 Matrix{Complex{BigFloat}}:
 0.0-0.0im  -0.0+0.0im  0.0+1.0im  0.0-0.0im
 0.0-0.0im  -0.0+0.0im  0.0+0.0im  1.0-0.0im
 0.0-1.0im  -0.0+0.0im  0.0+0.0im  0.0-0.0im
 0.0-0.0im  -1.0+0.0im  0.0+0.0im  0.0-0.0im</code></pre><pre><code class="language-julia-repl hljs">julia&gt; v = [1; 0; 0; 0];

julia&gt; wh(1,2,v) ≈ [0.0; 1.0im; 0.0; 0.0]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sflammia/Zauner.jl/f3a1fb6a1c9ccecc0fc65e88702fd585c6c1c3a1/src/algebraic.jl#L3-L35">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Zauner</a><a class="docs-footer-nextpage" href="../tables/">Tables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 29 January 2025 15:43">Wednesday 29 January 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
