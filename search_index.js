var documenterSearchIndex = {"docs":
[{"location":"functions/","page":"List of Functions","title":"List of Functions","text":"The following is a list of all exported functions in Zauner.","category":"page"},{"location":"functions/#Types","page":"List of Functions","title":"Types","text":"","category":"section"},{"location":"functions/","page":"List of Functions","title":"List of Functions","text":"AdmissibleTuple","category":"page"},{"location":"functions/#Zauner.AdmissibleTuple-functions","page":"List of Functions","title":"Zauner.AdmissibleTuple","text":"AdmissibleTuple( d::Integer [, Q::QuadBin])\nAdmissibleTuple( d::Integer, r::Integer [, Q::QuadBin])\nAdmissibleTuple( D::Integer, j::Integer, m::Integer [, Q::QuadBin])\n\nAdmissibleTuple( dQ::Tuple{Integer, QuadBin{ZZRingElem}})\nAdmissibleTuple( drQ::Tuple{Integer, Integer, QuadBin{ZZRingElem}})\n\nData type for the arithmetic data defining a set of ghost overlaps.\n\nIf only one integer is given, it is interpreted as a dimension and assumed that the rank is r = 1. The syntax that takes three integers (D,j,m) requires that D is a fundamental discriminant for a real quadratic field.\n\nIn all three cases, if the optional argument Q is left unspecified, then it defaults to a principal form given by Q = binary_quadratic_form( 1, 2-n, 1), where n is the integer (d^2-1)/(r(d-r)), since this has mathrmdisc(Q) = n(n-4).\n\nThe final way to specify an input is as a tuple (d,Q) or (d,r,Q).\n\nThe defined (and precomputed) fields in an AdmissibleTuple are given by:\n\n    d ::Integer                     # dimension\n    r ::Integer                     # rank\n    n ::Integer                     # (d^2-1)/(r*(d-r))\n    K ::AbsSimpleNumField           # associated field K = ℚ(√n(n-4))\n    D ::Integer                     # fundamental discriminant of K\n    f ::Integer                     # conductor, where n*(n-4) = D*f^2\n    q ::Integer                     # conductor of Q\n    j ::Integer                     # grid vertical position\n    m ::Integer                     # grid horozontal position\n    a ::AbsSimpleNumFieldElem       # associated field generator √D\n    u ::AbsSimpleNumFieldOrderElem  # Zauner unit\n    H ::AbsSimpleNumField           # (lazy) ring class field for q*Z(K)\n    g ::NumFieldAut                 # (lazy) Galois automorphism in H s.t. g(√D) = -√D\n    h ::Integer                     # class number, or degree of H/K\n    G ::Vector{Integer}             # orders of class group generators\n    c ::Vector{QuadBin}             # basis of generator Q's for the class group\n    Q ::QuadBin                     # binary quadratic form\n    L ::Matrix{ZZRingElem}          # S(Q) generator\n    k ::Integer                     # L^k = I mod d\n    A ::Matrix{ZZRingElem}          # S_d(Q) generator\n    x ::BigFloat                    # positive root of Q\n    R ::BigFloat                    # log of u\n\nThe fields marked '(lazy)', namely 'H' and 'g', are not initialized at first since their computation is substantially more expensive than the other fields. Once they have been computed their values are memoized and do not have to be recomputed.\n\nFrom the way that H is computed currently, K is not recognized as a subfield. This could lead to some non-intuitive results. For example, the quadratic generator a is an element of K, but not a recognized element of H. If an explicit embedding is needed, it can be obtained using is_subfield(K,H).\n\nExamples\n\njulia> AdmissibleTuple(5)\nAdmissibleTuple( d = 5, K = ℚ(√12), q = 1, Q = ⟨1,-4,1⟩, h = 1 )\n\njulia> AdmissibleTuple(11,3)\nAdmissibleTuple( d = 11, r = 3, K = ℚ(√5), q = 1, Q = ⟨1,-3,1⟩, h = 1 )\n\njulia> AdmissibleTuple(5,1,1)\nAdmissibleTuple( d = 4, K = ℚ(√5), q = 1, Q = ⟨1,-3,1⟩, h = 1 )\n\njulia> AdmissibleTuple(11,binary_quadratic_form(3,-12,4))\nAdmissibleTuple( d = 11, K = ℚ(√24), q = 2, Q = ⟨3,-12,4⟩, h = 2 )\n\n\n\n\n\n","category":"type"},{"location":"functions/#Galois-groups","page":"List of Functions","title":"Galois groups","text":"","category":"section"},{"location":"functions/","page":"List of Functions","title":"List of Functions","text":"centralizer_elements\ngalois_elements\ngalois_group_structure\ngalois_normal_form\ngalois_orbit\ngalois_order_orbit\nstabilizer_elements","category":"page"},{"location":"functions/#Zauner.centralizer_elements-functions","page":"List of Functions","title":"Zauner.centralizer_elements","text":"centralizer_elements(F::AdmissibleTuple)\n\nCompute the elements of mathrmGL(2mathbbZd) that are in the centralizer of the stability group for F.\n\nExamples\n\nThe centralizer for d=5 has 24 elements.\n\njulia> F = AdmissibleTuple(5);\n\njulia> cent = centralizer_elements(F);\n\njulia> length(cent)\n24\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.galois_elements-functions","page":"List of Functions","title":"Zauner.galois_elements","text":"galois_elements(F::AdmissibleTuple)\ngalois_elements(d::Integer, gens::Vector{Matrix{ZZRingElem}}, ords::Vector{Integer})\n\nCompute one element from each coset of mathcalMmathcalS where mathcalM is a maximal abelian subgroup of mathrmGL(2mathbbZd) and mathcalS is the stabilizer of F. The second form takes the dimension d and the generators and orders of generators for the galois group, as is computed by galois_normal_form. The output is an array of Matrix{ZZRingElem} elements whose size is the the same as ords.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.galois_group_structure-functions","page":"List of Functions","title":"Zauner.galois_group_structure","text":"galois_group_structure(F::AdmissibleTuple)\n\nCompute the canonical form (decomposition into cyclic groups) for the Galois group using the Smith normal form.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.galois_normal_form-functions","page":"List of Functions","title":"Zauner.galois_normal_form","text":"galois_normal_form(F::AdmissibleTuple)\n\nCompute the normal form of the group mathcalMmathcalS where mathcalM is a maximal abelian subgroup of mathrmGL(2mathbbZd) and mathcalS is the stabilizer of F. This is group is (conjecturally) isomorphic to the Galois group. The output is a tuple (g,n) where g is a vector of generator matrices and n is a vector of the orders of those matrices in mathcalMmathcalS. This corresponds to the canonical decomposition mathbbZn_1  mathbbZn_2    mathbbZn_k where the n_j are each prime powers. The factors are canonical up to permutation (though the generators are not).\n\nExamples\n\njulia> F = AdmissibleTuple( 7, QuadBin(2,-4,1))\nAdmissibleTuple( d = 7, K = ℚ(√8), q = 1, Q = ⟨2,-4,1⟩, h = 1 )\n\njulia> g, n = galois_normal_form(F)\n(Matrix{ZZRingElem}[[6 0; 0 6], [2 0; 0 2]], [2, 3])\n\njulia> F = AdmissibleTuple(9)\nAdmissibleTuple( d = 9, K = ℚ(√60), q = 1, Q = ⟨1,-8,1⟩, h = 2 )\n\njulia> g, n = galois_normal_form(F)\n(Matrix{ZZRingElem}[[8 5; 4 3], [8 0; 0 8], [7 0; 0 7]], [3, 2, 3])\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.galois_orbit-functions","page":"List of Functions","title":"Zauner.galois_orbit","text":"galois_orbit(F::AdmissibleTuple)\ngalois_orbit(F::AdmissibleTuple, T::Matrix{ZZRingElem}, n::Integer)\n\nCompute a maximal Galois orbit. Output is a vector of Vector{Integer} elements lying on a maximal orbit for the tuple F. The second form computes the Galois orbit with the centralizer subgroup generated by T of order n removed.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.galois_order_orbit-functions","page":"List of Functions","title":"Zauner.galois_order_orbit","text":"galois_order_orbit(F::AdmissibleTuple)\n\nCompute the orders of the elements of the Galois group and a maximal orbit, output as a tuple.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.stabilizer_elements-functions","page":"List of Functions","title":"Zauner.stabilizer_elements","text":"stabilizer_elements(F::AdmissibleTuple)\n\nCompute the elements of mathrmGL(2mathbbZd) that are in the complete stabilizer for F, including the extra antiunitary symmetry (if present). The elements are ordered so that the identity element is first.\n\nExamples\n\njulia> F = AdmissibleTuple(7)\nAdmissibleTuple( d = 7, K = ℚ(√8), q = 2, Q = ⟨1,-6,1⟩, h = 1 )\n\njulia> stabilizer_elements(F)\n3-element Vector{Matrix{ZZRingElem}}:\n [1 0; 0 1]\n [6 6; 1 0]\n [0 1; 6 6]\n\n\n\n\n\n","category":"function"},{"location":"functions/#Analysis","page":"List of Functions","title":"Analysis","text":"","category":"section"},{"location":"functions/","page":"List of Functions","title":"List of Functions","text":"double_sine\ne\nq_pochhammer\nq_pochhammer_exp","category":"page"},{"location":"functions/#Zauner.double_sine-functions","page":"List of Functions","title":"Zauner.double_sine","text":"double_sine(x,ω1,ω2 [; points=21])\n\nThe double sine function, defined in terms of the double gamma function following Shintani's convention:\n\nS_2(xboldsymbolomega) = fracGamma_2(xboldsymbolomega)Gamma_2(omega_1+omega_2-xboldsymbolomega)\n\nThis is currently implemented for real values only.\n\nWhen 0  x  ω_1 + ω_2, log S_2 has the integral representation\n\n    log S_2(xboldsymbolω) = frac12 int_0^infty left(fracsinhbigl((ω_1 + ω_2 - 2x)tbigr)sinh(ω_1 t)sinh(ω_2 t) - fracω_1 + ω_2 - 2 xω_1 ω_2 tright) fracmathrmdtt\n\nEvaluation proceeds via numerical integration using adaptive Gauss quadrature using the optional keyword argument points set to 21 by default.\n\nIf x is outside this fundamental domain, then the following period shift formulas can be applied until the integral formula can be applied. We have\n\n    S_2(xboldsymbolω) = S_2(x + ω_1boldsymbolω)  bigl(2 sin(pi x  ω_2) bigr)\n\nand similarly with ω_1 and ω_2 exchanged. Note that S_2(xboldsymbolω) is symmetric with respect to ω_1 ω_2. In our implementation, we recursively shift by ω_2 until the fundamental domain is reached.\n\nNote: Many authors, including Koyama & Kurokawa, Kurokawa & Koyama, and Tangedal, use a convention which replaces S_2 by 1S_2 relative to our convention.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.e-functions","page":"List of Functions","title":"Zauner.e","text":"e(z)\n\nNormalized exponential function, e(z) = exp(2 pi i z).\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.q_pochhammer-functions","page":"List of Functions","title":"Zauner.q_pochhammer","text":"q_pochhammer(a, q, n)\n\nFinite q-Pochhammer symbol, prod_k=0^n-1 bigl(1-a q^kbigr).\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.q_pochhammer_exp-functions","page":"List of Functions","title":"Zauner.q_pochhammer_exp","text":"q_pochhammer_exp(z, τ, n)\n\nFinite exponential-variant q-Pochhammer symbol, extended to include n  0. Defined as\n\nvarpi_n(ztau) =\nbegincases\n        prod_j=0^n-1bigl(1-mathrme^2 pi i (z+j tau)bigr)\n        qquad  n0\n        \n        1 qquad  n=0\n        \n        prod_j=n^-1bigl(1-mathrme^2 pi i (z+j tau)bigr)^-1\n        qquad  n0\nendcases\n\n\n\n\n\n","category":"function"},{"location":"functions/#Binary-Quadratic-Forms","page":"List of Functions","title":"Binary Quadratic Forms","text":"","category":"section"},{"location":"functions/","page":"List of Functions","title":"List of Functions","text":"qmat\nquadbinid","category":"page"},{"location":"functions/#Zauner.qmat-functions","page":"List of Functions","title":"Zauner.qmat","text":"qmat(Q::QuadBin)\n\nThe matrix of a quadratic form Q.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.quadbinid-functions","page":"List of Functions","title":"Zauner.quadbinid","text":"quadbinid(D)\n\nThe principal reduced form with discriminant D.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SL(2,ℤ)","page":"List of Functions","title":"SL(2,ℤ)","text":"","category":"section"},{"location":"functions/","page":"List of Functions","title":"List of Functions","text":"is_sl2z\npsl2word\nrademacher\nsl2zorder","category":"page"},{"location":"functions/#Zauner.is_sl2z-functions","page":"List of Functions","title":"Zauner.is_sl2z","text":"is_sl2z(M)\n\nReturns true if the matrix M is a 2x2 integer matrix with determinant 1.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.psl2word-functions","page":"List of Functions","title":"Zauner.psl2word","text":"psl2word(v::Vector)\npsl2word(A::Matrix)\n\nReturn the product T^v_1 S T^v_2 SS T^v_n where S and T are the standard generators of mathrmSL(2mathbbZ).\n\nDecompose a matrix A in mathrmSL(2mathbbZ) into a product of S and T generators, modulo -I. Reduction is done using rounding up with ceiling (Hirzebruch-Jung or negative regular continued fraction reduction) and returning a product strictly in terms of S and T except for the first or final element, which might be negative.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.rademacher-functions","page":"List of Functions","title":"Zauner.rademacher","text":"rademacher(M)\n\nRademacher invariant of the mathrmSL(2mathbbZ) matrix M. Reference: Hans Rademacher Zur Theorie der Dedekindschen Summen Mathematische Zeitschriften vol 63, pp. 445–463 (1955).\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.sl2zorder-functions","page":"List of Functions","title":"Zauner.sl2zorder","text":"sl2zorder(L, d)\n\nFind the order of L bmod d where L is in mathrmSL(2mathbbZ). Brute force algorithm.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Hirzebruch-Jung-continued-fractions","page":"List of Functions","title":"Hirzebruch-Jung continued fractions","text":"","category":"section"},{"location":"functions/","page":"List of Functions","title":"List of Functions","text":"minimal_hj_stabilizer\nreduced_hj_orbit","category":"page"},{"location":"functions/#Zauner.minimal_hj_stabilizer-functions","page":"List of Functions","title":"Zauner.minimal_hj_stabilizer","text":"minimal_hj_stabilizer(V::Vector{QuadBin{ZZRingElem}},d)\n\nReturns a minimal form Q among those in V. Specifically, if V is a reduced HJ orbit then the output Q minimizes the length of the HJ expansion of the stabilizer of Q modulo d. The function assumes that Q.a > 0 for each form in V. To break ties on length, the algorithm further chooses a minimal form by minimizing according first to the sum of the absolute coefficients, then by the maximum absolute coefficient. See the internal function _quadcompare_sum_then_max for details of the comparison function used for sorting.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.reduced_hj_orbit-functions","page":"List of Functions","title":"Zauner.reduced_hj_orbit","text":"reduced_hj_orbit(q::QuadBin{ZZRingElem})\n\nReturns the reduced orbit under HJ reduction.\n\nExamples\n\njulia> reduced_hj_orbit(binary_quadratic_form(1,-4,1))\n3-element Vector{QuadBin{ZZRingElem}}:\n Binary quadratic form over ZZ: x^2 - 4*x*y + y^2\n Binary quadratic form over ZZ: 3*x^2 - 6*x*y + 2*y^2\n Binary quadratic form over ZZ: 2*x^2 - 6*x*y + 3*y^2\n\n\n\n\n\n","category":"function"},{"location":"functions/#Ghosts","page":"List of Functions","title":"Ghosts","text":"","category":"section"},{"location":"functions/","page":"List of Functions","title":"List of Functions","text":"ghost\nghostbasis\nghostclassfield\nghostelements","category":"page"},{"location":"functions/#Zauner.ghost-functions","page":"List of Functions","title":"Zauner.ghost","text":"ghost(F:AdmissibleTuple)\n\nCompute a ghost as a d × d matrix from the admissible tuple F.\n\nOnly rank-1 ghosts are supported at this time.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.ghostbasis-functions","page":"List of Functions","title":"Zauner.ghostbasis","text":"ghostbasis(d)\n\nCompute a generating set (under Gauss composition) for the allowed quadratic forms in dimension d.\n\nThis returns a dictionary where each key is a divisor f of the conductor of D = (d+1)*(d-3) and each value is the tuple (c,Q) where c[k] is the order of Q[k] under Gauss composition.\n\nExamples\n\njulia> ghostbasis(15)\nDict{ZZRingElem, Tuple{Vector{ZZRingElem}, Vector{QuadBin}}} with 3 entries:\n  4 => ([2], [Binary quadratic form over ZZ: 3*x^2 + 12*x*y - 4*y^2])\n  2 => ([1], [Binary quadratic form over ZZ: x^2 + 6*x*y - 3*y^2])\n  1 => ([1], [Binary quadratic form over ZZ: x^2 + 2*x*y - 2*y^2])\n\nIn this example, Q = QuadBin(3,12,-4) has order 2, so we have Q^2 == QuadBin(1,12,-12) since this is the principal form with the same discriminant.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.ghostclassfield-functions","page":"List of Functions","title":"Zauner.ghostclassfield","text":"ghostclassfield( K::AbsSimpleNumField, q)\nghostclassfield( F::AdmissibleTuple)\n\nCompute the ring class field for the order q*ℤ(K) where ℤ(K) is the maximal order in K. The output is an LLL-reduced AbsSimpleNumField, and so is an absolute field rather than a relative extension.\n\nGiven an AdmissibleTuple F it initializes the field F.H to be this ring class field.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.ghostelements-functions","page":"List of Functions","title":"Zauner.ghostelements","text":"ghostelements(d)\n\nCompute a representative quadratic form for each ghost class in dimension d. There are a total of numsics(d) such forms. These forms are merely Euclidean reduced, not Hirzebruch-Jung reduced.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Necromancy","page":"List of Functions","title":"Necromancy","text":"","category":"section"},{"location":"functions/","page":"List of Functions","title":"List of Functions","text":"guess_int_null_vec\nmatrix_completion\nnecromancy\npow_to_elem_sym_poly","category":"page"},{"location":"functions/#Zauner.guess_int_null_vec-functions","page":"List of Functions","title":"Zauner.guess_int_null_vec","text":"guess_int_null_vec( x::Vector{BigFloat})\n\nUse LLL to find an integer relation among the elements of x.\n\nExamples\n\njulia> guess_int_null_vec(BigFloat.([1; sin(big(pi)/8)^2; sin(big(pi)/4)]))\n3-element Vector{BigInt}:\n -1\n  2\n  1\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.matrix_completion-functions","page":"List of Functions","title":"Zauner.matrix_completion","text":"matrix_completion( nu::AbstractArray, F::AdmissibleTuple\n[; verbose::Bool = false, shift::Integer = 0, test::Bool = false,\nmax_iters = 1e5, eps_abs = 1e-7, eps_infeas = 1e-7, eps_rel = 1e-7])\n\nGiven the SIC phase overlaps nu on a maximal galois orbit, compute the associated SIC fiducial vector ψ. If the input does not correspond to a valid SIC with admissible data F, then the output is unpredictable.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.necromancy-functions","page":"List of Functions","title":"Zauner.necromancy","text":"necromancy( F::AdmissibleTuple [; max_prec = 2^20, verbose = false])\n\nCompute a numerical approximations to a SIC associated to the AdmissibleTuple F. The maximum number of bits used in integer relation finding is set to max_prec (default of 1 Mb) and verbose can be toggled true or false.\n\nExamples\n\nCheck that the principal SIC in d=7 satisfies the equiangularity conditions.\n\njulia> d = 7; F = AdmissibleTuple(d)\nAdmissibleTuple( d = 7, K = ℚ(√8), q = 2, Q = ⟨1,-6,1⟩, h = 1 )\n\njulia> ψ = necromancy(F);\n\njulia> all([ abs2(ψ'wh(p,ψ)) for p=1:d^2-1] .≈ 1/(d+1))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.pow_to_elem_sym_poly-functions","page":"List of Functions","title":"Zauner.pow_to_elem_sym_poly","text":"pow_to_elem_sym_poly( p::AbstractVector)\n\nConvert a vector of power sums to elementary symmetric polynomials. Assumes that that p[k] is the power sum of degree k. No check is done to ensure that the input is a valid collection of power sums, it simply applies the relevant recursion relation. Output e is indexed so that e[1] == 1 is the zeroth elementary symmetric polynomial and length(e) == length(p)+1.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Newton's-method","page":"List of Functions","title":"Newton's method","text":"","category":"section"},{"location":"functions/","page":"List of Functions","title":"List of Functions","text":"precision_bump\nprecision_bump!\nre_im_proj","category":"page"},{"location":"functions/#Zauner.precision_bump-functions","page":"List of Functions","title":"Zauner.precision_bump","text":"precision_bump(ψ::Vector{Complex{BigFloat}}, prec::Integer [; base::Integer = 10, verbose::Bool = true])\nprecision_bump(ψ::Vector{Complex{BigFloat}}, f::Function, prec::Integer [; base::Integer = 10, verbose::Bool = true])\n\nAttempt to use Newton's method to improve the precision of ψ to at least prec digits in base base. In the second version, the function f is used for root finding.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.precision_bump!-functions","page":"List of Functions","title":"Zauner.precision_bump!","text":"precision_bump!(z::Vector{BigFloat}, prec::Integer [; base::Integer = 10, verbose::Bool = true])\nprecision_bump!(z::Vector{BigFloat}, f::Function, prec::Integer [; base::Integer = 10, verbose::Bool = true])\n\nAttempt to use Newton's method to improve the precision of z to at least prec digits in base base, where z is the real projective representation of ψ. In the second version, the function f is used for root finding.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.re_im_proj-functions","page":"List of Functions","title":"Zauner.re_im_proj","text":"re_im_proj(ψ::Vector{Complex{BigFloat}})\nre_im_proj(z::Vector{BigFloat})\n\nStack the real and imaginary parts of the vector ψ and normalize so that the first coordinate, assumed nonzero, is normalized to 1 and then dropped.\n\nIf called with type Vector{BigFloat} then it does the inverse transformation, taking an even-length real vector to a complex one with unit first coordinate.\n\nExamples\n\nA simple example:\n\nv = Complex{BigFloat}.([ 1; im; -1; -im])\nre_im_proj(v)\n\n# output\n\n6-element Vector{BigFloat}:\n  0.0\n -1.0\n  0.0\n  1.0\n  0.0\n -1.0\n\n\n\n\n\n","category":"function"},{"location":"functions/#Validation","page":"List of Functions","title":"Validation","text":"","category":"section"},{"location":"functions/","page":"List of Functions","title":"List of Functions","text":"ghost_frame_test\nghost_overlap_test\nsic_frame_test\nsic_overlap_test","category":"page"},{"location":"functions/#Zauner.ghost_frame_test-functions","page":"List of Functions","title":"Zauner.ghost_frame_test","text":"ghost_frame_test(ψ::AbstractVector)\n\nReturn the maximum absolute deviation of the pointwise frame conditions. This is the ghost analog of eq. 8 of arXiv:0707.2071.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.ghost_overlap_test-functions","page":"List of Functions","title":"Zauner.ghost_overlap_test","text":"ghost_overlap_test(ψ::AbstractVector)\n\nCheck the ghost overlap conditions. If all ghost overlaps are approximately real, it returns\n\nmax_boldsymbolp not=boldsymbol0 biglnu_boldsymbolp nu_-boldsymbolp - tfrac1d+1bigr\n\nIf they aren't approximately real it throws an error.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.sic_frame_test-functions","page":"List of Functions","title":"Zauner.sic_frame_test","text":"sic_frame_test(ψ::AbstractVector)\n\nReturn the absolute deviation of the pointwise conditions on the frame potential from eq. 8 of arXiv:0707.2071. Let T(kl) = sum_j psi_jpsi_j+k^* psi_j+l^* psi_j+k+l, and recall that psi is a SIC if and only if T(kl) - fracdelta_k0+delta_l0d+1 = 0. The function returns the maximum absolute deviation from these conditions.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.sic_overlap_test-functions","page":"List of Functions","title":"Zauner.sic_overlap_test","text":"sic_overlap_test(ψ::AbstractVector)\n\nCheck the SIC equiangularity conditions by returning\n\nmax_boldsymbolp not=boldsymbol0 biglnu_boldsymbolp nu_-boldsymbolp - tfrac1d+1bigr\n\nwhere nu_boldsymbolp = langlepsiD_boldsymbolppsirangle are the SIC overlaps.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Real-quadratic-orders","page":"List of Functions","title":"Real quadratic orders","text":"","category":"section"},{"location":"functions/","page":"List of Functions","title":"List of Functions","text":"class_group_structure\ncoredisc\npell\npellreg\nquadclassunit\nsignswitch","category":"page"},{"location":"functions/#Zauner.class_group_structure-functions","page":"List of Functions","title":"Zauner.class_group_structure","text":"class_group_structure(D)\n\nReturns class group structure for the quadratic order with disciminant D.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.coredisc-functions","page":"List of Functions","title":"Zauner.coredisc","text":"coredisc(D)\ncoredisc(Q::QuadBin)\n\nOutputs a tuple (Δ,f) of the fundamental discriminant Δ and conductor f of D, or of a binary quadratic form with discriminant D.\n\nExamples\n\nHere are two examples with fundamental discriminant 5 and conductor 3.\n\njulia> coredisc(45) # 45 = 3^2 * 5\n(5, 3)\n\njulia> coredisc( binary_quadratic_form(1,-7,1) ) # -4*det( [1 -7//2; -7//2 1]) == 3^2 * 5\n(5, 3)\n\nSee also conductor.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.pell-functions","page":"List of Functions","title":"Zauner.pell","text":"pell(D)\npell(Q::QuadBin)\npell(Zω::AbsSimpleNumFieldOrder)\n\nFinds the least unit > 1 having norm 1 for the discriminant D, for the binary quadratic form with discriminant D, or the quadratic order ℤ(ω) where ω = frac12bigl( (D mod 4) +  sqrtDbigr).\n\nExample\n\nThe fundamental unit for ℚ(sqrt5) is (sqrt5+1)2, but this has norm -1, so we return the square of this.\n\njulia> pell(5)\n1//2*sqrt(5) + 3//2\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.pellreg-functions","page":"List of Functions","title":"Zauner.pellreg","text":"pellreg(D)\npellreg(Q::QuadBin)\npellreg(Zω::AbsSimpleNumFieldOrder)\n\nFinds the least unit > 1 having norm 1 for the discriminant D, for the binary quadratic form with discriminant D, or the quadratic order ℤ(ω) where ω = frac12bigl( (D mod 4) +  sqrtDbigr). The output is a tuple with the unit and a BigFloat of the log of that unit (which is just the regulator of ℤ(ω), or twice that if the fundamental unit has norm -1).\n\nwarning: Warning\nA limitation of the current implementation is that the regulator is only correct to about 128 bits, even though it returns a number to the current precision of BigFloat.\n\nSee also pell.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.quadclassunit-functions","page":"List of Functions","title":"Zauner.quadclassunit","text":"quadclassunit(D)\n\nReturns class group and unit group data for the quadratic order with disciminant D. Let omega = bigl(Deltabmod 4 + sqrtDeltabigr)2, so that a mathbbZ-basis is mathbbZ+omegamathbbZ. Then the output is a tuple (h,c,b,u), where\n\nh is the class number,\nc is an integer vector for the cycle stucture of the class group, mathbbZn_1 + ldots + mathbbZn_r.\nb is a vector of binary quadratic forms that generate the corresponding factor in the class group,\nu is the totally positive fundamental unit with norm 1, written as [x,y] in the above basis.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.signswitch-functions","page":"List of Functions","title":"Zauner.signswitch","text":"signswitch( H::AbsSimpleNumField, D::Integer)\nsignswitch( F::AdmissibleTuple)\n\nIf H is the (absolute) ring class field for a ghost with fundamental discriminant D with some conductor, then this finds a sign-switching Galois automorphism g on H, that is gbigl(sqrtDbigr) = -sqrtD.\n\nIf F is an AdmissibleTuple then is initializes the field F.g. This requires that the field F.H has already been initialized with ghostclassfield.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Property-testing","page":"List of Functions","title":"Property testing","text":"","category":"section"},{"location":"functions/","page":"List of Functions","title":"List of Functions","text":"has_fa_symmetry\nis_admissible\nis_antiunitary\nis_antiunitary_with_generator","category":"page"},{"location":"functions/#Zauner.has_fa_symmetry-functions","page":"List of Functions","title":"Zauner.has_fa_symmetry","text":"has_fa_symmetry(F::AdmissibleTuple)\n\nTest for F_a symmetry as opposed to Zauner (F_z) symmetry.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.is_admissible-functions","page":"List of Functions","title":"Zauner.is_admissible","text":"is_admissible( d::Integer [, Q::QuadBin])\nis_admissible( d::Integer, r::Integer [, Q::QuadBin])\nis_admissible( D::Integer, j::Integer, m::Integer [, Q::QuadBin])\n\nTest whether the arguments form an admissible tuple.\n\nExamples\n\njulia> is_admissible(5,1)\ntrue\n\njulia> is_admissible(5,2)\nfalse\n\njulia> is_admissible(5,1,1)\ntrue\n\njulia> is_admissible(5,2,1,binary_quadratic_form(1,-7,1))\ntrue\n\njulia> is_admissible(11,1,binary_quadratic_form(3,-12,4))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.is_antiunitary-functions","page":"List of Functions","title":"Zauner.is_antiunitary","text":"is_antiunitary(F::AdmissibleTuple)\n\nTest if the tuple F has antiunitary symmetry.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.is_antiunitary_with_generator-functions","page":"List of Functions","title":"Zauner.is_antiunitary_with_generator","text":"is_antiunitary_with_generator(F::AdmissibleTuple)\n\nTest if the tuple F has antiunitary symmetry and return a tuple: if the first output is true, the second element of the tuple is a symmetry generator, and if false, the second output is the zero matrix.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Utilities","page":"List of Functions","title":"Utilities","text":"","category":"section"},{"location":"functions/","page":"List of Functions","title":"List of Functions","text":"dq\nnumsics\nradix\nwh","category":"page"},{"location":"functions/#Zauner.dq-functions","page":"List of Functions","title":"Zauner.dq","text":"dq(k)\n\nPrecomputed values of admissible tuples (d,Q) with d ≤ 256, comprising the first 3292 such inequivalent tuples when ordered by dimension. The forms Q have been chosen (non-uniquely) to minimize the period of the Hirzebruch-Jung continued fraction expansion of their positive root.\n\nExamples\n\njulia> dq(1)\n(4, Binary quadratic form over ZZ: x^2 - 3*x*y + y^2)\n\nIt can also be called with collections to access multiple tuples.\n\njulia> dq(20:23)\n4-element Vector{Tuple{Int64, QuadBin{ZZRingElem}}}:\n (15, Binary quadratic form over ZZ: x^2 - 4*x*y + y^2)\n (15, Binary quadratic form over ZZ: 4*x^2 - 8*x*y + y^2)\n (15, Binary quadratic form over ZZ: x^2 - 14*x*y + y^2)\n (15, Binary quadratic form over ZZ: 11*x^2 - 18*x*y + 3*y^2)\n\nThe associated AdmissibleTuple can be obtained directly.\n\njulia> AdmissibleTuple(dq(2))\nAdmissibleTuple( d = 5, K = ℚ(√12), q = 1, Q = ⟨1,-4,1⟩, h = 1 )\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.numsics-functions","page":"List of Functions","title":"Zauner.numsics","text":"numsics(d)\n\nNumber of WH 1-SICs in dimension d, modulo EC orbits.\n\nExample\n\nHere are the number of inequivalent 1-SICs for dimensions 4-15:\n\njulia> foreach(d -> println( (d, numsics(d)) ), 4:15)\n(4, 1)\n(5, 1)\n(6, 1)\n(7, 2)\n(8, 2)\n(9, 2)\n(10, 1)\n(11, 3)\n(12, 2)\n(13, 2)\n(14, 2)\n(15, 4)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.radix-functions","page":"List of Functions","title":"Zauner.radix","text":"radix(n,r)\n\nThe length(r) least significant digits of the integer n in mixed radix r = [r1; r2; ...; rk].\n\nExamples\n\njulia> radix(5,[2; 2; 2; 2; 2])\n5-element Vector{Int64}:\n 0\n 0\n 1\n 0\n 1\n\njulia> radix(86400,[7; 24; 60; 60])\n4-element Vector{Int64}:\n 1\n 0\n 0\n 0\n\n\n\n\n\n","category":"function"},{"location":"functions/#Zauner.wh-functions","page":"List of Functions","title":"Zauner.wh","text":"wh( p::Vector{<:Integer}, d::Integer [, T::Type = BigFloat])\nwh( m::Integer, n::Integer, d::Integer [, T::Type = BigFloat])\n\nwh( p::Vector{<:Integer}, v::Vector)\nwh( m::Integer, n::Integer, v::Vector)\nwh( n::Integer, v::Vector)\n\nWeyl-Heisenberg displacement operators. We have wh(p,q,d) == wh([p,q],d) acts on the standard basis as krangle to v_d^p q ω_d^qk+prangle, where arithmetic inside the ket is modulo d and where ω_d = v_d^2 and v_d = -mathrme^i πd. These forms explicitly construct the matrix that acts this way where 0 is the first element of the basis.\n\nThe forms wh(p,v) or wh(m,n,v) give the action onto the vector v without explicitly forming the matrix. This is much faster when working with high dimensions or high precision. The form wh(n,v) with d = length(v) simply converts the integer n into the base-d expansion n = n_1 d + n_0 and calls wh([n1,n0],v). Tuples can also be used in place of vectors in these function calls.\n\nExamples\n\njulia> wh(2,3,4)\n4×4 Matrix{Complex{BigFloat}}:\n 0.0-0.0im  -0.0+0.0im  0.0+1.0im  0.0-0.0im\n 0.0-0.0im  -0.0+0.0im  0.0+0.0im  1.0-0.0im\n 0.0-1.0im  -0.0+0.0im  0.0+0.0im  0.0-0.0im\n 0.0-0.0im  -1.0+0.0im  0.0+0.0im  0.0-0.0im\n\njulia> v = [1; 0; 0; 0];\n\njulia> wh(1,2,v) ≈ [0.0; 1.0im; 0.0; 0.0]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"","page":"Zauner","title":"Zauner","text":"using Zauner","category":"page"},{"location":"#Zauner","page":"Zauner","title":"Zauner","text":"","category":"section"},{"location":"","page":"Zauner","title":"Zauner","text":"Zauner is a Julia module for computing properties of SICs (or SIC-POVMs) and related objects such as rank-r versions of SICs (r-SICs), objects that are galois conjugates of these called ghosts, and certain Stark units over real quadratic fields. The properties of ghosts, SICs, and Stark units computed by Zauner are, in most cases, only known to hold conjecturally. This package is a systematic way to test Zauner's conjecture and certain Stark conjectures, generate new conjectures, and sharpen (or refute!) existing ones.","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"warning: Warning\nThis package is still in its infancy. Expect breaking changes in upcoming versions.","category":"page"},{"location":"#Getting-Started","page":"Zauner","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Zauner","title":"Zauner","text":"Here's how to get started.","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"using Zauner","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"With Julia 1.10 or later, you should be prompted to install Zauner if you haven't done so already. If you're running an older version of Julia, you can first install Zauner by running import Pkg; Pkg.add(\"Zauner\").","category":"page"},{"location":"#Admissible-Tuples","page":"Zauner","title":"Admissible Tuples","text":"","category":"section"},{"location":"","page":"Zauner","title":"Zauner","text":"The ghosts constructed by Zauner are parameterized by an AdmissibleTuple. This can be specified in one of several ways. A rank-1 ghost in dimension d > 3 is specified up to equivalence by d and a suitable quadratic form Q. Thus, we have","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"d = 7\nQ = binary_quadratic_form(2,-4,1)\nt = AdmissibleTuple(d,Q)","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"We see that the AdmissibleTuple type precomputes several associated data from d,Q.","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"t.K # associated field\nt.h # class number / size of multiplet\n(t.j, t.m) # dimension grid positions\nt.D # fundamental discriminant","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"The complete set of fields is given in the documentation for AdmissibleTuple.","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"If no quadratic form is given, then AdmissibleTuple defaults to the principal form.","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"t = AdmissibleTuple(7)\nt.Q # form","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"An AdmissibleTuple can be used to do explicit computations of ghosts. From the previous tuple, we have the following ghost (reduced from default BigFloat precision):","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"v = ComplexF64.(ghost(t))","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"Note that ghosts are normalized so that the first coordinate is 1. To get the properly normalized ghost overlaps and validate the solution, one can do the following to compute ghost overlaps:","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"u = circshift(reverse(v),1); # parity-reversed ghost\nnu_plus  = real.( [u' * wh( [ p; q], v) / (u'v) for p=0:d-1, q=0:d-1] )\nnu_minus = real.( [u' * wh( [-p;-q], v) / (u'v) for p=0:d-1, q=0:d-1] )\n(d + 1) .* nu_plus .* nu_minus","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"Here wh(p,v) acts a Weyl-Heisenberg displacement operator indexed by p onto v, i.e., in quantum notation it returns D_boldsymbolpvrangle.","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"It can also be used with necromancy to attempt to reconstruct a 1-SIC, which we again round down from BigFloat precision.","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"ψ = ComplexF64.(necromancy(t))","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"Zauner provides numerical validation by measuring how far the returned objects are from satisfing the overlap conditions or minimizing the \"pointwise\" frame potential conditions discussed below.","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"ghost_overlap_test(v)\nsic_overlap_test(ψ)\nghost_frame_test(v)\nsic_frame_test(ψ)","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"warning: Warning\nRank r1 has very limited support at the moment and is essentially confined to the definition of an AdmissibleTuple. Many other functions have limited domains at present. For example, we do not presently support necromancy on F_a orbits. Please file an issue on GitHub if there is something you wish to see supported in future updates.","category":"page"},{"location":"#Citing-Zauner","page":"Zauner","title":"Citing Zauner","text":"","category":"section"},{"location":"","page":"Zauner","title":"Zauner","text":"How to cite us:","category":"page"},{"location":"","page":"Zauner","title":"Zauner","text":"@misc{AFK2025,\n\tarchiveprefix = {arXiv},\n\tauthor = {Appleby, Marcus and Flammia, Steven T. and Kopp, Gene S.},\n\teprint = {2501.03970},\n\thowpublished = {arXiv:2501.03970},\n\tprimaryclass = {math.NT},\n\ttitle = {A constructive approach to Zauner's conjecture via the Stark conjectures},\n\tyear = {2025}\n}","category":"page"},{"location":"tables/#Admissible-tuple-data-tables","page":"Tables","title":"Admissible tuple data tables","text":"","category":"section"},{"location":"tables/","page":"Tables","title":"Tables","text":"This table contains algebraic data for each inequivalent admissible tuple in dimensions 4–35, comprising 100 total tuples. This list is conjecturally complete for all Weyl-Heisenberg covariant SICs in these dimensions. Each admissible tuple is specified by a dimension d and an integer binary quadratic form Q as follows. First factorize (d+1)(d-3)=s^2Delta_0 where Delta_0 is a fundamental discriminant. Then $ (d,Q) $ gives an admissible tuple if mathrmdisc(Q) = f^2Delta_0 where f divides s. The other columns can be computed from these data, but they may be difficult to compute, for example requiring integer factoring or finding a fundamental unit. The column Delta_0 contains the fundamental discriminant of Q and h is the order of the class group mathrmCl(mathcalO_f), given in the next two columns respectively. The Galois group mathrmGal(E_t^(1)H) of the candidate overlap field ramified at the first infinite place over the class field H of K=mathbbQ(sqrtDelta_0) is given in the next column. As both the class group and the Galois group are finite and abelian, we give the canonical decomposition into cyclic groups C_k of order k. The column L^n contains a generator L of the stability group of Q in mathrmGL_2(mathbbZ) and its order n in mathrmGL_2(mathbbZbard); that is, treating Q as a symmetric matrix we have L^T Q L = det(L) Q and L^n = 1 (bmod bard). If the tuple has antiunitary symmetry, we denote this with a Y in the a.u. column. Finally, ell is the length of the word expansion of L^n using the Hirzebruch-Jung (negative regular) reduction into the standard (S and T) generators of mathrmSL_2(mathbbZ). This is one measure of the complexity of constructing the actual fiducial vector for that input. The Q in this list were selected among class representatives to minimize this complexity, although this choice is not generally unique. The data here are sufficient to compute a ghost fiducial in each class, but to fully specify a SIC, one must additionally choose a sign-switching Galois automorphism sqrtDelta_0to-sqrtDelta_0 over an appropriate field extension of K.","category":"page"},{"location":"tables/","page":"Tables","title":"Tables","text":"d Delta_0 f h mathrmCl(mathcalO_f) mathrmGal(EH) Q L^n textau ell\n4 5 1 1 $ C_{1} $ C_2^2 langle1-31rangle left(beginsmallmatrix2-11-1endsmallmatrixright)^6 textY 4\n5 12 1 1 $ C_{1} $ C_8 langle1-41rangle left(beginsmallmatrix4-110endsmallmatrixright)^3  4\n6 21 1 1 $ C_{1} $ C_2timesC_6 langle1-51rangle left(beginsmallmatrix5-110endsmallmatrixright)^3  4\n7 8 1 1 $ C_{1} $ C_6 langle2-41rangle left(beginsmallmatrix3-12-1endsmallmatrixright)^6 textY 7\n  2 1 $ C_{1} $ C_2timesC_6 langle1-61rangle left(beginsmallmatrix6-110endsmallmatrixright)^3  4\n8 5 1 1 $ C_{1} $ C_2timesC_4 langle1-31rangle left(beginsmallmatrix2-11-1endsmallmatrixright)^12 textY 7\n  3 1 $ C_{1} $ C_2timesC_4^2 langle1-71rangle left(beginsmallmatrix7-110endsmallmatrixright)^3  4\n9 60 1 2 C_2 C_3timesC_6 langle1-81rangle left(beginsmallmatrix8-110endsmallmatrixright)^3  4\n      langle5-102rangle left(beginsmallmatrix9-25-1endsmallmatrixright)^3  7\n10 77 1 1 $ C_{1} $ C_2timesC_24 langle1-91rangle left(beginsmallmatrix9-110endsmallmatrixright)^3  4\n11 24 1 1 $ C_{1} $ C_40 langle3-61rangle left(beginsmallmatrix11-26-1endsmallmatrixright)^3  7\n  2 2 C_2 C_40 langle1-101rangle left(beginsmallmatrix10-110endsmallmatrixright)^3  4\n      langle3-124rangle left(beginsmallmatrix11-43-1endsmallmatrixright)^3  7\n12 13 1 1 $ C_{1} $ C_2^4 langle3-51rangle left(beginsmallmatrix4-13-1endsmallmatrixright)^6 textY 10\n  3 1 $ C_{1} $ C_2^3timesC_6 langle1-111rangle left(beginsmallmatrix11-110endsmallmatrixright)^3  4\n13 140 1 2 C_2 C_4timesC_12 langle1-121rangle left(beginsmallmatrix12-110endsmallmatrixright)^3  4\n      langle7-142rangle left(beginsmallmatrix13-27-1endsmallmatrixright)^3  7\n14 165 1 2 C_2 C_2timesC_6^2 langle1-131rangle left(beginsmallmatrix13-110endsmallmatrixright)^3  4\n      langle5-153rangle left(beginsmallmatrix14-35-1endsmallmatrixright)^3  7\n15 12 1 1 $ C_{1} $ C_24 langle1-41rangle left(beginsmallmatrix4-110endsmallmatrixright)^6  7\n  2 1 $ C_{1} $ C_2timesC_24 langle4-81rangle left(beginsmallmatrix15-28-1endsmallmatrixright)^3  7\n  4 2 C_2 C_2timesC_24 langle1-141rangle left(beginsmallmatrix14-110endsmallmatrixright)^3  4\n      langle11-183rangle left(beginsmallmatrix16-311-2endsmallmatrixright)^3  10\n16 221 1 2 C_2 C_2timesC_8^2 langle1-151rangle left(beginsmallmatrix15-110endsmallmatrixright)^3  4\n      langle7-195rangle left(beginsmallmatrix17-57-2endsmallmatrixright)^3  10\n17 28 1 1 $ C_{1} $ C_96 langle2-61rangle left(beginsmallmatrix17-36-1endsmallmatrixright)^3  7\n  3 2 C_2 C_96 langle1-161rangle left(beginsmallmatrix16-110endsmallmatrixright)^3  4\n      langle9-182rangle left(beginsmallmatrix17-29-1endsmallmatrixright)^3  7\n18 285 1 2 C_2 C_3timesC_6^2 langle1-171rangle left(beginsmallmatrix17-110endsmallmatrixright)^3  4\n      langle13-213rangle left(beginsmallmatrix19-313-2endsmallmatrixright)^3  10\n19 5 1 1 $ C_{1} $ C_18 langle1-31rangle left(beginsmallmatrix2-11-1endsmallmatrixright)^18 textY 10\n  2 1 $ C_{1} $ C_3timesC_18 langle4-61rangle left(beginsmallmatrix5-14-1endsmallmatrixright)^6 textY 13\n  4 1 $ C_{1} $ C_6timesC_18 langle5-101rangle left(beginsmallmatrix19-210-1endsmallmatrixright)^3  7\n  8 2 C_2 C_6timesC_18 langle1-181rangle left(beginsmallmatrix18-110endsmallmatrixright)^3  4\n      langle5-204rangle left(beginsmallmatrix19-45-1endsmallmatrixright)^3  7\n20 357 1 2 C_2 C_2^3timesC_24 langle1-191rangle left(beginsmallmatrix19-110endsmallmatrixright)^3  4\n      langle7-213rangle left(beginsmallmatrix20-37-1endsmallmatrixright)^3  7\n21 44 1 1 $ C_{1} $ C_2^2timesC_24 langle5-81rangle left(beginsmallmatrix22-315-2endsmallmatrixright)^3  10\n  3 4 C_4 C_2timesC_6^2 langle1-201rangle left(beginsmallmatrix20-110endsmallmatrixright)^3  4\n      langle5-249rangle left(beginsmallmatrix22-95-2endsmallmatrixright)^3  10\n      langle11-222rangle left(beginsmallmatrix21-211-1endsmallmatrixright)^3  7\n      langle9-245rangle left(beginsmallmatrix22-59-2endsmallmatrixright)^3  10\n22 437 1 1 $ C_{1} $ C_2timesC_120 langle1-211rangle left(beginsmallmatrix21-110endsmallmatrixright)^3  4\n23 120 1 2 C_2 C_176 langle6-121rangle left(beginsmallmatrix23-212-1endsmallmatrixright)^3  7\n      langle3-122rangle left(beginsmallmatrix23-46-1endsmallmatrixright)^3  7\n  2 4 C_2^2 C_176 langle1-221rangle left(beginsmallmatrix22-110endsmallmatrixright)^3  4\n      langle19-10-5rangle left(beginsmallmatrix165196endsmallmatrixright)^3  13\n      langle8-243rangle left(beginsmallmatrix23-38-1endsmallmatrixright)^3  7\n      langle150-8rangle left(beginsmallmatrix1181511endsmallmatrixright)^3  10\n24 21 1 1 $ C_{1} $ C_2timesC_4timesC_12 langle1-51rangle left(beginsmallmatrix5-110endsmallmatrixright)^6  7\n  5 2 C_2 C_2^2timesC_4timesC_12 langle1-231rangle left(beginsmallmatrix23-110endsmallmatrixright)^3  4\n      langle17-273rangle left(beginsmallmatrix25-317-2endsmallmatrixright)^3  10\n25 572 1 2 C_2 C_5timesC_40 langle1-241rangle left(beginsmallmatrix24-110endsmallmatrixright)^3  4\n      langle13-262rangle left(beginsmallmatrix25-213-1endsmallmatrixright)^3  7\n26 69 1 1 $ C_{1} $ C_2timesC_12^2 langle3-91rangle left(beginsmallmatrix26-39-1endsmallmatrixright)^3  7\n  3 3 C_3 C_2timesC_12^2 langle1-251rangle left(beginsmallmatrix25-110endsmallmatrixright)^3  4\n      langle17-3-9rangle left(beginsmallmatrix1491711endsmallmatrixright)^3  10\n      langle5-2911rangle left(beginsmallmatrix27-115-2endsmallmatrixright)^3  10\n27 168 1 2 C_2 C_9timesC_18 langle7-141rangle left(beginsmallmatrix27-214-1endsmallmatrixright)^3  7\n      langle11-162rangle left(beginsmallmatrix29-422-3endsmallmatrixright)^3  13\n  2 4 C_2^2 C_9timesC_18 langle1-261rangle left(beginsmallmatrix26-110endsmallmatrixright)^3  4\n      langle714-17rangle left(beginsmallmatrix617720endsmallmatrixright)^3  7\n      langle19-8-8rangle left(beginsmallmatrix178199endsmallmatrixright)^3  10\n      langle11-328rangle left(beginsmallmatrix29-811-3endsmallmatrixright)^3  10\n28 29 1 1 $ C_{1} $ C_2^2timesC_6^2 langle5-71rangle left(beginsmallmatrix6-15-1endsmallmatrixright)^6 textY 16\n  5 2 C_2 C_2^3timesC_6^2 langle1-271rangle left(beginsmallmatrix27-110endsmallmatrixright)^3  4\n      langle13-337rangle left(beginsmallmatrix30-713-3endsmallmatrixright)^3  13\n29 780 1 4 C_2^2 C_280 langle1-281rangle left(beginsmallmatrix28-110endsmallmatrixright)^3  4\n      langle15-302rangle left(beginsmallmatrix29-215-1endsmallmatrixright)^3  7\n      langle10-303rangle left(beginsmallmatrix29-310-1endsmallmatrixright)^3  7\n      langle6-305rangle left(beginsmallmatrix29-56-1endsmallmatrixright)^3  7\n30 93 1 1 $ C_{1} $ C_2timesC_6timesC_24 langle7-111rangle left(beginsmallmatrix31-321-2endsmallmatrixright)^3  10\n  3 3 C_3 C_2timesC_6timesC_24 langle1-291rangle left(beginsmallmatrix29-110endsmallmatrixright)^3  4\n      langle19-1-11rangle left(beginsmallmatrix15111914endsmallmatrixright)^3  10\n      langle7-339rangle left(beginsmallmatrix31-97-2endsmallmatrixright)^3  10\n31 56 1 1 $ C_{1} $ C_10timesC_30 langle2-81rangle left(beginsmallmatrix31-48-1endsmallmatrixright)^3  7\n  2 2 C_2 C_10timesC_30 langle8-161rangle left(beginsmallmatrix31-216-1endsmallmatrixright)^3  7\n      langle112-5rangle left(beginsmallmatrix13102217endsmallmatrixright)^3  13\n  4 4 C_4 C_10timesC_30 langle1-301rangle left(beginsmallmatrix30-110endsmallmatrixright)^3  4\n      langle13-345rangle left(beginsmallmatrix32-513-2endsmallmatrixright)^3  10\n      langle25-364rangle left(beginsmallmatrix33-425-3endsmallmatrixright)^3  13\n      langle5-3413rangle left(beginsmallmatrix32-135-2endsmallmatrixright)^3  10\n32 957 1 2 C_2 C_2timesC_16^2 langle1-311rangle left(beginsmallmatrix31-110endsmallmatrixright)^3  4\n      langle11-333rangle left(beginsmallmatrix32-311-1endsmallmatrixright)^3  7\n33 1020 1 4 C_2^2 C_2timesC_120 langle1-321rangle left(beginsmallmatrix32-110endsmallmatrixright)^3  4\n      langle17-342rangle left(beginsmallmatrix33-217-1endsmallmatrixright)^3  7\n      langle23-363rangle left(beginsmallmatrix34-323-2endsmallmatrixright)^3  10\n      langle29-405rangle left(beginsmallmatrix36-529-4endsmallmatrixright)^3  16\n34 1085 1 2 C_2 C_2timesC_288 langle1-331rangle left(beginsmallmatrix33-110endsmallmatrixright)^3  4\n      langle7-355rangle left(beginsmallmatrix34-57-1endsmallmatrixright)^3  7\n35 8 1 1 $ C_{1} $ C_6timesC_12 langle2-41rangle left(beginsmallmatrix3-12-1endsmallmatrixright)^12 textY 13\n  2 1 $ C_{1} $ C_2timesC_6timesC_12 langle1-61rangle left(beginsmallmatrix6-110endsmallmatrixright)^6  7\n  3 1 $ C_{1} $ C_2timesC_6timesC_24 langle7-101rangle left(beginsmallmatrix37-428-3endsmallmatrixright)^3  13\n  4 1 $ C_{1} $ C_2timesC_6timesC_24 langle4-121rangle left(beginsmallmatrix35-312-1endsmallmatrixright)^3  7\n  6 2 C_2 C_2timesC_6timesC_24 langle9-181rangle left(beginsmallmatrix35-218-1endsmallmatrixright)^3  7\n      langle4-207rangle left(beginsmallmatrix37-148-3endsmallmatrixright)^3  10\n  12 4 C_4 C_2timesC_6timesC_24 langle1-341rangle left(beginsmallmatrix34-110endsmallmatrixright)^3  4\n      langle168-17rangle left(beginsmallmatrix13171621endsmallmatrixright)^3  13\n      langle4-369rangle left(beginsmallmatrix35-94-1endsmallmatrixright)^3  7\n      langle28-12-9rangle left(beginsmallmatrix2392811endsmallmatrixright)^3  13","category":"page"}]
}
